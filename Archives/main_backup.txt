# main.py
import json
import os
import shutil
import time
import logging
from datetime import date, datetime
from typing import List, Dict, Any
import pandas as pd
import numpy as np
from pykrx import stock
import base64
import io
import hashlib
import csv

# --- 신규 라이브러리 종속성 ---
# 설치: pip install matplotlib seaborn python-dateutil
try:
    import matplotlib.pyplot as plt
    import matplotlib.font_manager as fm
    import seaborn as sns
except ImportError:
    print("Warning: 'matplotlib' or 'seaborn' not installed. Please run: pip install matplotlib seaborn")
    plt = None
    sns = None

try:
    from dateutil.relativedelta import relativedelta
except ImportError:
    relativedelta = None
    print("Warning: 'python-dateutil' not installed. pip install python-dateutil")

# --- 로깅 및 Matplotlib 한글 폰트 설정 ---
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

def setup_matplotlib_font():
    """운영체제에 맞는 한글 폰트를 찾아 Matplotlib에 설정"""
    if plt is None:
        return
    font_paths = [
        '/usr/share/fonts/truetype/nanum/NanumGothic.ttf',  # Linux (Ubuntu)
        'C:/Windows/Fonts/malgun.ttf',                      # Windows
        '/System/Library/Fonts/Supplemental/AppleGothic.ttf'  # macOS
    ]
    font_name = None
    for font_path in font_paths:
        if os.path.exists(font_path):
            fm.fontManager.addfont(font_path)
            font_name = fm.FontProperties(fname=font_path).get_name()
            break
            
    if font_name:
        plt.rc('font', family=font_name)
        logging.info(f"Matplotlib 한글 폰트 설정 완료: {font_name}")
    else:
        logging.warning("한글 폰트를 찾을 수 없어 기본 폰트를 사용합니다.")
    
    plt.rc('axes', unicode_minus=False) # 마이너스 부호 깨짐 방지

setup_matplotlib_font()

# ------------------------------------------------------------------------------
# 안전한 폴더 정리 함수
# ------------------------------------------------------------------------------
def safe_clear_folder(path: str, extension: str = None):
    if not os.path.exists(path):
        os.makedirs(path, exist_ok=True)
        return
    for item in os.listdir(path):
        item_path = os.path.join(path, item)
        try:
            if extension is None or item.endswith(extension):
                if os.path.isfile(item_path) or os.path.islink(item_path):
                    os.unlink(item_path)
                elif os.path.isdir(item_path):
                    shutil.rmtree(item_path)
        except Exception as e:
            logging.warning(f"Failed to delete {item_path}. Reason: {e}")

# ==============================================================================
# 1. 데이터 로더 (Data Loader)
# ==============================================================================
class DataLoader:
    """주식/벤치마크 데이터 다운로드 및 캐싱 담당"""
    def __init__(self, data_path='data'):
        self.script_dir = os.path.dirname(os.path.abspath(__file__))
        self.data_path = os.path.join(self.script_dir, data_path)
        os.makedirs(self.data_path, exist_ok=True)

    def _coerce_price_df(self, df: pd.DataFrame) -> pd.DataFrame:
        if df is None or df.empty: return pd.DataFrame()
        df.index = pd.to_datetime(df.index.astype(str), errors='coerce')
        for col in ["Open", "High", "Low", "Close", "Adj Close", "Volume"]:
            if col in df.columns:
                df[col] = pd.to_numeric(df[col].astype(str).str.replace(',', ''), errors='coerce')
        df = df[~df.index.isna()]
        return df

    def get_price_data(self, ticker: str, start_date: str, end_date: str) -> pd.DataFrame:
        clean_ticker = ticker.split('.')[0]
        fname = os.path.join(self.data_path, f"{clean_ticker}_{start_date}_{end_date}.csv")
        if os.path.exists(fname):
            logging.info(f"Using cache for price data: {ticker}")
            df = pd.read_csv(fname, index_col=0)
            return self._coerce_price_df(df)
        logging.info(f"Downloading price data for: {ticker}")
        df = self._fetch_ticker_history(ticker, start_date, end_date)
        if not df.empty:
            df = self._coerce_price_df(df)
            df.to_csv(fname)
        return df

    def get_benchmark_data(self, ticker: str, start_date: str, end_date: str) -> pd.DataFrame:
        fname = os.path.join(self.data_path, f"BENCHMARK_{ticker}_{start_date}_{end_date}.csv")
        if os.path.exists(fname):
            logging.info(f"Using cache for benchmark data: {ticker}")
            df = pd.read_csv(fname, index_col=0)
            return self._coerce_price_df(df)
        logging.info(f"Downloading benchmark data for: {ticker}")
        try:
            df = stock.get_index_ohlcv(start_date.replace('-', ''), end_date.replace('-', ''), ticker)
            df.rename(columns={'시가':'Open','고가':'High','저가':'Low','종가':'Close','거래량':'Volume'}, inplace=True)
            df['Adj Close'] = df['Close']
            df.index.name = 'Date'
            df = self._coerce_price_df(df)
            if not df.empty: df.to_csv(fname)
            return df
        except Exception as e:
            logging.error(f"Failed to download benchmark data for {ticker}: {e}")
            return pd.DataFrame()

    def _fetch_ticker_history(self, ticker: str, start: str, end: str, max_retries=3, pause=1.0) -> pd.DataFrame:
        ticker_code = ticker.split('.')[0]
        for attempt in range(1, max_retries + 1):
            try:
                df = stock.get_market_ohlcv(start.replace('-', ''), end.replace('-', ''), ticker_code)
                if df.empty: return pd.DataFrame()
                df.rename(columns={'시가': 'Open', '고가': 'High', '저가': 'Low', '종가': 'Close', '거래량': 'Volume'}, inplace=True)
                df['Adj Close'] = df['Close']
                df.index.name = 'Date'
                return self._coerce_price_df(df)
            except Exception as e:
                logging.warning(f"Download failed for {ticker} attempt {attempt}: {e}")
                time.sleep(pause * (2 ** (attempt - 1)))
        return pd.DataFrame()

# ==============================================================================
# 2. 지표 계산기 (Indicator Calculator)
# ==============================================================================
class IndicatorCalculator:
    """전략에 필요한 모든 기술적 지표 계산"""
    def __init__(self, data: pd.DataFrame):
        self.data = data.copy()

    def calculate_all(self, strategy: Dict) -> pd.DataFrame:
        for indicator in strategy.get('indicators', []):
            self._calculate_indicator(indicator)
        self._calculate_atr(strategy)
        self._calculate_take_profit_indicators(strategy)
        return self.data.dropna()

    def _calculate_indicator(self, config: Dict):
        name, type_ = config['name'], config['type']
        params = config.get('params', {})
        try:
            if type_ == 'SMA':
                self.data[name] = self.data[params['source']].rolling(window=params['window']).mean()
            elif type_ == 'CALCULATION':
                self.data[name] = self.data.eval(params['formula'])
        except Exception as e:
            logging.error(f"Error evaluating indicator '{name}': {e}")

    def _calculate_atr(self, strategy: Dict):
        atr_scenario = next((s for s in strategy.get('optimization_config', {}).get('stop_loss_scenarios', []) if s['type']=='ATR'), None)
        if not atr_scenario: return
        window = atr_scenario['params']['atr_window']
        high_low = self.data['High'] - self.data['Low']
        high_close = np.abs(self.data['High'] - self.data['Close'].shift())
        low_close = np.abs(self.data['Low'] - self.data['Close'].shift())
        tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
        self.data['ATR'] = tr.ewm(alpha=1/window, adjust=False).mean()

    def _calculate_take_profit_indicators(self, strategy: Dict):
        config = strategy.get('take_profit_config', {})
        if not config.get('enabled', False) or config.get('type') != 'MA_DIRECTION_TRAIL':
            return
        
        p = config.get('params', {})
        if 'window_range_start' in p and 'window_range_end' in p and 'step' in p:
            for window in range(p['window_range_start'], p['window_range_end'] + 1, p['step']):
                ma_name = f"SMA_{window}"
                dir_name = f"{ma_name}_DIR"
                if 'source' in p:
                    self.data[ma_name] = self.data[p['source']].rolling(window=window).mean()
                    self.data[dir_name] = (self.data[ma_name].diff() > 0).astype(int)

# ==============================================================================
# 3. 백테스팅 엔진 (Backtesting Engine)
# ==============================================================================
class Backtester:
    """단일 파라미터 조합에 대한 백테스트 수행"""
    def __init__(self, data_with_indicators: pd.DataFrame, strategy: Dict):
        self.data = data_with_indicators
        self.strategy = strategy
        self.buy_price = 0

    def run_single_backtest(self, sl_rule: Dict, tp_rule: Dict, initial_capital=1e8) -> Dict:
        cash = initial_capital
        position = 0
        self.buy_price = 0
        entry_date = None
        
        trades = []
        equity_curve = pd.Series(index=self.data.index, dtype=float)
        equity_curve.iloc[0] = initial_capital

        for i in range(2, len(self.data)):
            day_before_prev_row = self.data.iloc[i-2]
            prev_row = self.data.iloc[i-1]
            row = self.data.iloc[i]
            
            equity_curve.iloc[i] = cash + (position * row['Close'])

            if position > 0:
                exit_triggered = False
                sell_price = row['Open']

                stop_loss_price = self._calculate_stop_loss_price(prev_row, self.buy_price, sl_rule)
                if sl_rule and stop_loss_price > 0 and row['Low'] < stop_loss_price:
                    exit_triggered = True
                    sell_price = min(row['Open'], stop_loss_price)

                if not exit_triggered and self.strategy.get('take_profit_config', {}).get('enabled', False):
                    tp_conf = self.strategy['take_profit_config']
                    if self._check_condition_recursive(row, prev_row, day_before_prev_row, tp_conf.get('params', {})):
                        exit_triggered = True

                if exit_triggered:
                    cash += position * sell_price
                    trades.append({'entry': entry_date, 'exit': row.name, 'profit_pct': (sell_price - self.buy_price) / self.buy_price if self.buy_price > 0 else 0})
                    position, self.buy_price, entry_date = 0, 0, None
            
            if position == 0:
                if self._check_condition_recursive(row, prev_row, day_before_prev_row, self.strategy['buy_conditions']):
                    self.buy_price = row['Open']
                    entry_date = row.name
                    shares_to_buy = int(cash / self.buy_price) 
                    if shares_to_buy > 0:
                        position = shares_to_buy
                        cash -= position * self.buy_price
        
        if len(self.data) > 0:
            final_value = cash + (position * self.data.iloc[-1]['Close'])
            if len(equity_curve) > 1:
                equity_curve.iloc[-1] = final_value
                equity_curve = equity_curve.ffill()
        else:
            final_value = initial_capital
        
        return {'final_value': final_value, 'initial_capital': initial_capital, 'trades': trades, 'equity_curve': equity_curve}

    def _check_condition_recursive(self, current_row: pd.Series, prev_row: pd.Series, day_before_prev_row: pd.Series, cond_group: Dict) -> bool:
        if not cond_group or 'conditions' not in cond_group:
            return False

        logic = cond_group.get('logic', 'AND').upper()
        results = []
        
        for cond in cond_group.get('conditions', []):
            if 'logic' in cond:
                results.append(self._check_condition_recursive(current_row, prev_row, day_before_prev_row, cond))
            else:
                op = cond.get('op')
                left_key = cond.get('left')
                right_str = cond.get('right')
                is_true = False

                if op == 'crosses_above':
                    left_prev = prev_row.get(left_key)
                    right_prev = prev_row.get(right_str)
                    left_before = day_before_prev_row.get(left_key)
                    right_before = day_before_prev_row.get(right_str)
                    if not pd.isna([left_prev, right_prev, left_before, right_before]).any():
                        if (left_before <= right_before) and (left_prev > right_prev):
                            is_true = True
                
                elif op == 'crosses_below':
                    left_prev = prev_row.get(left_key)
                    right_prev = prev_row.get(right_str)
                    left_before = day_before_prev_row.get(left_key)
                    right_before = day_before_prev_row.get(right_str)
                    if not pd.isna([left_prev, right_prev, left_before, right_before]).any():
                        if (left_before >= right_before) and (left_prev < right_prev):
                            is_true = True
                
                else: 
                    row_to_use = current_row if self.buy_price > 0 else prev_row
                    left_val = row_to_use.get(left_key)
                    
                    try:
                        eval_locals = row_to_use.to_dict()
                        eval_locals['average_entry_price'] = self.buy_price
                        right_val = eval(str(right_str), {}, eval_locals)
                    except Exception:
                        right_val = right_str

                    if not pd.isna(left_val) and not pd.isna(right_val):
                        op_map = {'<': left_val < right_val, '>': left_val > right_val,
                                  '<=': left_val <= right_val, '>=': left_val >= right_val,
                                  '==': left_val == right_val, '!=': left_val != right_val}
                        is_true = op_map.get(op, False)
                
                results.append(is_true)

        if not results: return False
        return all(results) if logic == 'AND' else any(results)

    def _calculate_stop_loss_price(self, prev_row: pd.Series, buy_price: float, sl_rule: Dict) -> float:
        if not sl_rule or sl_rule.get('type') is None: return 0.0
        if sl_rule['type']=='PREV_DAY_LOW': return prev_row['Low']
        elif sl_rule['type']=='FIXED_PERCENTAGE': return buy_price * (1 - sl_rule['params']['percentage'])
        elif sl_rule['type']=='ATR': return buy_price - (prev_row.get('ATR', 0) * sl_rule['params']['multiplier'])
        return 0.0

# ==============================================================================
# 4. 최적화 엔진 (Optimizer)
# ==============================================================================
class Optimizer:
    def __init__(self, data_with_indicators: pd.DataFrame, strategy: Dict):
        self.data = data_with_indicators
        self.strategy = strategy
        self.backtester = Backtester(self.data, self.strategy)

    def run_optimization(self):
        if not self.strategy.get('optimization_config', {}).get('enabled', True):
            logging.info("Optimization disabled. Running single backtest with default rules.")
            sl_default = {'name': 'Default SL', 'type': None}
            tp_default = {'name': 'Default TP', 'type': None}
            performance = self.backtester.run_single_backtest(sl_default, tp_default)
            performance['Stop-Loss Rule'] = sl_default['name']
            performance['Take-Profit Rule'] = tp_default['name']
            performance['Trades'] = len(performance['trades'])
            return [performance]

        sl_scenarios = self._generate_sl_scenarios()
        tp_scenarios = self._generate_tp_scenarios()
        results = []
        total_scenarios = len(sl_scenarios) * len(tp_scenarios)
        logging.info(f"Starting optimization: {total_scenarios} scenarios to test...")
        for sl in sl_scenarios:
            for tp in tp_scenarios:
                performance = self.backtester.run_single_backtest(sl, tp)
                results.append({
                    'Stop-Loss Rule': sl['name'], 'Take-Profit Rule': tp['name'],
                    'final_value': performance['final_value'], 'initial_capital': performance['initial_capital'],
                    'Trades': len(performance['trades']), 'trades': performance['trades'],
                    'equity_curve': performance['equity_curve']
                })
        return results
    
    def _generate_sl_scenarios(self):
        scenarios = []
        config = self.strategy.get('optimization_config', {}).get('stop_loss_scenarios', [])
        for s in config:
            if s['type']=='PREV_DAY_LOW': scenarios.append(s)
            elif s['type']=='FIXED_PERCENTAGE':
                p = s['params']
                for val in np.arange(p['range_start'], p['range_end']+p['step'], p['step']):
                    scenarios.append({'name':f'Fixed {val:.0%}','type':s['type'],'params':{'percentage':val}})
            elif s['type']=='ATR':
                p = s['params']
                for m in np.arange(p['multiplier_range_start'], p['multiplier_range_end']+p['step'], p['step']):
                    scenarios.append({'name':f'ATR {m:.1f}x','type':s['type'],'params':{'multiplier':m}})
        return scenarios if scenarios else [{'name': 'None', 'type': None}]

    def _generate_tp_scenarios(self):
        scenarios = []
        config = self.strategy.get('take_profit_config', {})
        if not config.get('enabled', False) or config.get('type') != 'MA_DIRECTION_TRAIL':
             return [{'name': 'None', 'type': None}]
        p = config['params']
        for w in range(p['window_range_start'], p['window_range_end']+1, p['step']):
            scenarios.append({'name':f'SMA({w}) Dir. Trail', 'type': config['type'], 'window':w})
        return scenarios if scenarios else [{'name': 'None', 'type': None}]

# ==============================================================================
# 5. 성과 분석기 (PerformanceAnalyzer)
# ==============================================================================
class PerformanceAnalyzer:
    @staticmethod
    def calculate_all_metrics(result: Dict, equity_curve: pd.Series = None) -> Dict:
        if equity_curve is None: equity_curve = result.get('equity_curve')
        metrics = {}
        if equity_curve is not None and not equity_curve.empty and len(equity_curve) > 1:
            start_val, end_val = equity_curve.iloc[0], equity_curve.iloc[-1]
            days = (equity_curve.index[-1] - equity_curve.index[0]).days
            metrics['CAGR'] = ((end_val/start_val)**(365.0/days)-1)*100 if days>0 and start_val>0 else 0
            peak = equity_curve.cummax()
            dd = (equity_curve / peak - 1)
            metrics['MDD'] = dd.min() * 100
            rets = equity_curve.pct_change().dropna()
            metrics['Sharpe'] = (rets.mean()/rets.std()*np.sqrt(252)) if rets.std()!=0 else 0
            metrics['Final P/L %'] = (end_val/start_val - 1)*100
        else:
            metrics.update({'CAGR': 0, 'MDD': 0, 'Sharpe': 0, 'Final P/L %': 0})

        trades = result.get('trades', [])
        metrics['Num Trades'] = len(trades)
        if trades:
            wins = [t for t in trades if t['profit_pct'] > 0]
            metrics['WinRate'] = (len(wins)/len(trades))*100 if trades else 0.0
            gross_profit = sum(t['profit_pct'] for t in wins)
            gross_loss = abs(sum(t['profit_pct'] for t in trades if t['profit_pct'] <= 0))
            metrics['ProfitFactor'] = gross_profit/gross_loss if gross_loss > 0 else float('inf')
        else:
            metrics['WinRate'], metrics['ProfitFactor'] = 0.0, "N/A"
        return metrics

# ==============================================================================
# 6. 리포트 생성기 (ReportGenerator)
# ==============================================================================
class ReportGenerator:
    def __init__(self, reports_path='reports'):
        self.reports_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), reports_path)
        os.makedirs(self.reports_path, exist_ok=True)
    def _convert_fig_to_base64(self, fig) -> str:
        buf = io.BytesIO()
        fig.savefig(buf, format='png', bbox_inches='tight')
        plt.close(fig)
        return base64.b64encode(buf.getvalue()).decode('utf-8')
    def generate_heatmap(self, results: List[Dict]) -> str:
        if not results or len(results) < 2: return ""
        df = pd.DataFrame(results)
        try:
            pivot_df = df.pivot_table(index='Stop-Loss Rule', columns='Take-Profit Rule', values='final_value')
            if pivot_df.shape[0] < 1 or pivot_df.shape[1] < 1: return ""
            fig, ax = plt.subplots(figsize=(12, max(6, len(pivot_df.index)*0.5)))
            sns.heatmap(pivot_df, annot=True, fmt=',.0f', cmap='viridis', ax=ax)
            ax.set_title('Optimization Heatmap (Final Equity)')
            return self._convert_fig_to_base64(fig)
        except Exception as e:
            logging.error(f"Failed to generate heatmap: {e}")
            return ""
    def generate_html_report(self, ticker: str, all_results: List[Dict], best_result: Dict, metrics: Dict, benchmark: pd.DataFrame, strategy: Dict):
        equity_curve = best_result['equity_curve']
        fig, ax = plt.subplots(figsize=(12, 6))
        ax.plot(equity_curve.index, equity_curve.values, label='Strategy Equity', color='blue')
        if not benchmark.empty:
            bench_curve = benchmark['Close']/benchmark['Close'].iloc[0]*equity_curve.iloc[0]
            ax.plot(bench_curve.index, bench_curve.values, label='Benchmark (KOSPI)', color='grey', linestyle='--')
        ax.set_title(f'Performance Report: {ticker}')
        ax.legend()
        img_base64 = self._convert_fig_to_base64(fig)

        heatmap_html = ""
        if strategy.get('optimization_config', {}).get('enabled', False):
            heatmap_img = self.generate_heatmap(all_results)
            if heatmap_img:
                heatmap_html = f'<h2>파라미터 최적화 히트맵</h2><img src="data:image/png;base64,{heatmap_img}" />'
        
        metrics_map = {'CAGR': 'CAGR (%, 연)', 'MDD': 'MDD (%)', 'Sharpe': 'Sharpe Ratio', 'WinRate': '승률 (%)', 'ProfitFactor': '손익비', 'Num Trades': '총 거래 횟수'}
        metrics_table_html = "<table><tr><th>지표</th><th>값</th></tr>"
        for key, name in metrics_map.items():
            value = metrics.get(key)
            if isinstance(value, float):
                metrics_table_html += f"<tr><td>{name}</td><td>{value:.2f}</td></tr>"
            else:
                metrics_table_html += f"<tr><td>{name}</td><td>{value}</td></tr>"
        metrics_table_html += "</table>"

        html = f"""
        <html><head><meta charset='utf-8'><title>Report {ticker}</title>
        <style>body{{font-family:sans-serif;}} table{{border-collapse:collapse;}} th,td{{padding:8px;border:1px solid #ddd;}}</style>
        </head><body>
        <h1>성과 리포트: {ticker}</h1>
        <h2>최적 조합: {best_result.get('Stop-Loss Rule', 'N/A')} & {best_result.get('Take-Profit Rule', 'N/A')}</h2>
        <h2>핵심 지표</h2>{metrics_table_html}
        <h2>자산 곡선 (Equity Curve)</h2><img src="data:image/png;base64,{img_base64}" />
        {heatmap_html}</body></html>
        """
        out_path = os.path.join(self.reports_path, f"{ticker}_report.html")
        with open(out_path,'w',encoding='utf-8') as f: f.write(html)
        logging.info(f"Report generated: {out_path}")
        
    def generate_portfolio_summary_report(self, portfolio_metrics: Dict, portfolio_equity: pd.Series, individual_results: List[Dict], benchmark: pd.DataFrame, annual_df: pd.DataFrame):
        fig1, ax1 = plt.subplots(figsize=(12, 6))
        ax1.plot(portfolio_equity.index, portfolio_equity.values, label='Portfolio Equity')
        bench_equity = benchmark['Close'] / benchmark['Close'].iloc[0] * portfolio_equity.iloc[0]
        ax1.plot(bench_equity.index, bench_equity.values, label='Benchmark (KOSPI)', linestyle='--')
        ax1.set_title('포트폴리오 누적 수익률 곡선 (Portfolio vs KOSPI)')
        ax1.legend()
        img1_b64 = self._convert_fig_to_base64(fig1)

        metrics_map = {'CAGR': 'CAGR (%, 연)', 'MDD': 'MDD (%)', 'Sharpe': 'Sharpe Ratio', 'WinRate': '승률 (%)', 'ProfitFactor': '손익비 (전체 거래 기준)', 'Final P/L %': '누적 수익률 (%)', 'Num Trades': '총 거래 횟수'}
        metrics_html = "<table><tr><th>지표</th><th>값</th></tr>"
        for key, name in metrics_map.items():
            value = portfolio_metrics.get(key)
            if isinstance(value, float):
                 metrics_html += f"<tr><td>{name}</td><td>{value:.2f}</td></tr>"
            else:
                metrics_html += f"<tr><td>{name}</td><td>{value}</td></tr>"
        metrics_html += "</table>"
        desc_html = "<p style='font-size: smaller; color: grey;'><i>전략 기본 규칙: 포트폴리오 성과는 개별 종목 성과의 산술 평균입니다.</i></p>"

        def style_excess_return(val):
            color = '#0000FF' if val > 0 else '#FF0000' if val < 0 else 'black'
            return f'color: {color}'
        
        annual_html = ""
        if not annual_df.empty:
            annual_styled = annual_df.style.format('{:+.2f}%').map(style_excess_return, subset=['초과 성과 (Portfolio - KOSPI)'])
            annual_html = annual_styled.to_html().replace('<table border="1" class="dataframe">','<table>')
        
        fig2, ax2 = plt.subplots(figsize=(12, 6))
        if not annual_df.empty:
            annual_df.plot(kind='bar', y=['Portfolio', 'Benchmark'], ax=ax2)
            ax2.set_title('연도별 수익률 비교 (Annual Returns)')
            ax2.set_ylabel('Return (%)')
            ax2.tick_params(axis='x', rotation=45)
        img2_b64 = self._convert_fig_to_base64(fig2)
        
        individual_html = "<table><tr><th>종목</th><th>CAGR(%)</th><th>MDD(%)</th><th>Sharpe</th><th>거래 수</th><th>최적 SL 규칙</th><th>최적 TP 규칙</th></tr>"
        for res in sorted(individual_results, key=lambda x: x['metrics']['CAGR'], reverse=True):
            individual_html += f"""
            <tr><td>{res['ticker']}</td><td>{res['metrics']['CAGR']:.2f}</td><td>{res['metrics']['MDD']:.2f}</td><td>{res['metrics']['Sharpe']:.2f}</td>
            <td>{res['metrics']['Num Trades']}</td><td>{res['best_result']['Stop-Loss Rule']}</td><td>{res['best_result']['Take-Profit Rule']}</td></tr>
            """
        individual_html += "</table>"
        
        html = f"""
        <html><head><meta charset='utf-8'><title>Portfolio Summary</title>
        <style>body{{font-family:sans-serif;}} table{{border-collapse:collapse; margin-bottom: 20px;}} th,td{{padding:8px;border:1px solid #ddd; text-align:left;}}</style>
        </head><body>
        <h1>포트폴리오 종합 성과 리포트</h1><h2>Part 1: 종합 성과</h2>{metrics_html}{desc_html}
        <img src="data:image/png;base64,{img1_b64}" width="800"/>
        <h2>Part 2: 연도별 성과</h2>{annual_html}
        <img src="data:image/png;base64,{img2_b64}" width="800"/>
        <h2>Part 3: 개별 종목 요약</h2>{individual_html}</body></html>
        """
        out_path = os.path.join(self.reports_path, "_Portfolio_Summary_Report.html")
        with open(out_path, 'w', encoding='utf-8') as f: f.write(html)
        logging.info(f"Portfolio summary report generated: {out_path}")

    @staticmethod
    def print_terminal_summary(portfolio_metrics: Dict):
        print("\n" + "="*50 + "\n          PORTFOLIO SUMMARY REPORT\n" + "="*50)
        metrics_map = {'CAGR': 'CAGR (%, 연)', 'MDD': 'MDD (%)', 'Sharpe': 'Sharpe Ratio', 'WinRate': '승률 (%)', 'ProfitFactor': '손익비', 'Num Trades': '총 거래 횟수'}
        display_data = {name: (f"{portfolio_metrics.get(key):.2f}" if isinstance(portfolio_metrics.get(key), float) else portfolio_metrics.get(key)) for key, name in metrics_map.items()}
        df = pd.DataFrame.from_dict(display_data, orient='index', columns=['Value'])
        print(df)
        print("="*50)

    @staticmethod
    def generate_ai_commentary(portfolio_metrics: Dict, benchmark_metrics: Dict, annual_df: pd.DataFrame, individual_results: List[Dict]) -> str:
        final_comment = ["[AI 종합 분석 코멘트]"]
        part1_comments, part2_comments, part3_comments = ["- [종합 성과]"], ["- [연도별 성과 분석]"], ["- [개별 종목 성과 요약]"]
        cagr_p = portfolio_metrics.get('CAGR', 0)
        cagr_b = benchmark_metrics.get('CAGR', 0)
        mdd_p, sharpe_p = portfolio_metrics.get('MDD', 0), portfolio_metrics.get('Sharpe', 0)

        part1_comments.append(f"포트폴리오의 CAGR은 {cagr_p:.2f}%로, 벤치마크({cagr_b:.2f}%) 대비 {'우수한' if cagr_p > cagr_b else '부진한'} 성과를 보였습니다.")
        if sharpe_p > 1.0: part1_comments.append(f"샤프 지수가 {sharpe_p:.2f}로 높아, 효율적인 위험 관리가 이루어졌음을 시사합니다.")
        if mdd_p < -20: part1_comments.append(f"최대 낙폭(MDD)은 {mdd_p:.2f}%로, 상당한 리스크가 존재할 수 있음을 인지해야 합니다.")
        final_comment.append("\n".join(part1_comments))

        if not annual_df.empty:
            outperform_years = (annual_df['초과 성과 (Portfolio - KOSPI)'] > 0).sum()
            part2_comments.append(f"총 {len(annual_df)}년 중 {outperform_years}년 동안 벤치마크를 상회했습니다.")
        final_comment.append("\n".join(part2_comments))

        if individual_results:
            sorted_by_cagr = sorted(individual_results, key=lambda x: x['metrics'].get('CAGR', -np.inf), reverse=True)
            if sorted_by_cagr:
                part3_comments.append(f"'{sorted_by_cagr[0]['ticker']}' 종목이 CAGR {sorted_by_cagr[0]['metrics']['CAGR']:.2f}%로 최고의 성과를 보였습니다.")
        final_comment.append("\n".join(part3_comments))
        
        disclaimer = "\n\n[법적 고지 사항]\n본 분석은 과거 데이터를 기반으로 한 시뮬레이션 결과이며, 미래의 수익을 보장하지 않습니다."
        return "\n\n".join(final_comment) + disclaimer

# ==============================================================================
# 7. 테스트 이력 관리 (History Manager)
# ==============================================================================
class HistoryManager:
    def __init__(self, history_file='test_history.csv'):
        self.history_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), history_file)
        self.headers = ['Timestamp', 'Strategy File', 'Strategy Hash', 'Tickers', 'Portfolio CAGR', 'Portfolio MDD', 'Portfolio Sharpe']
    def _get_strategy_hash(self, file_path: str) -> str:
        hasher = hashlib.sha256()
        with open(file_path, 'rb') as f: hasher.update(f.read())
        return hasher.hexdigest()
    def update_history(self, strategy_file_path: str, tickers: List[str], portfolio_metrics: Dict):
        if not os.path.exists(self.history_file):
            with open(self.history_file, 'w', newline='', encoding='utf-8') as f:
                csv.writer(f).writerow(self.headers)
        new_row = {'Timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'), 'Strategy File': os.path.basename(strategy_file_path), 'Strategy Hash': self._get_strategy_hash(strategy_file_path), 'Tickers': ', '.join(tickers), 'Portfolio CAGR': f"{portfolio_metrics.get('CAGR', 0):.2f}", 'Portfolio MDD': f"{portfolio_metrics.get('MDD', 0):.2f}", 'Portfolio Sharpe': f"{portfolio_metrics.get('Sharpe', 0):.2f}"}
        with open(self.history_file, 'a', newline='', encoding='utf-8') as f:
            csv.DictWriter(f, fieldnames=self.headers).writerow(new_row)
        logging.info(f"Test history updated in {self.history_file}")

# ==============================================================================
# 메인 실행 블록
# ==============================================================================
if __name__ == "__main__":
    try:
        base_dir = os.path.dirname(os.path.abspath(__file__))

        # --- 사용자 입력으로 전략 파일 지정 ---
        strategy_filename = input(">>> 실행할 전략 파일명을 입력하세요 (예: envelope_final_strategy.json): ")
        strategy_file_path = os.path.join(base_dir, 'strategies', strategy_filename)

        if not os.path.exists(strategy_file_path):
            logging.error(f"전략 파일을 찾을 수 없습니다: {strategy_file_path}")
            exit()
        
        try:
            with open(strategy_file_path, 'r', encoding='utf-8') as f:
                strategy_config = json.load(f)
            logging.info(f"전략 파일 로드 성공: {strategy_filename}")
        except json.JSONDecodeError:
            logging.error(f"전략 파일이 올바른 JSON 형식이 아닙니다: {strategy_file_path}")
            exit()

        # --- 환경 초기화 ---
        safe_clear_folder(os.path.join(base_dir, 'reports'), extension='.html')
        logging.info("Cleared .html files in reports folder.")

        # --- 설정 로드 (config.json) ---
        config_path = os.path.join(base_dir,'config.json')
        with open(config_path,'r',encoding='utf-8') as f: app_config = json.load(f)

        # --- 날짜 및 종목 설정 ---
        tickers = app_config.get('tickers',[])
        end_date_obj = date.today() if app_config.get('end_date')=='today' else date.fromisoformat(app_config['end_date'])
        start_date_obj = end_date_obj - relativedelta(years=5) if relativedelta and app_config.get('start_date')=='5_years_ago' else date.fromisoformat(app_config['start_date'])
        start_date, end_date = start_date_obj.isoformat(), end_date_obj.isoformat()

        # --- 모듈 인스턴스화 ---
        data_loader = DataLoader()
        report_gen = ReportGenerator()
        history_manager = HistoryManager()
        
        # --- 벤치마크 데이터 로드 ---
        benchmark_data = data_loader.get_benchmark_data('1001', start_date, end_date)

        # --- 개별 종목 백테스팅 루프 ---
        all_individual_results = []
        for ticker in tickers:
            logging.info(f"--- 분석 시작: {ticker} ---")
            price_data = data_loader.get_price_data(ticker, start_date, end_date)
            if price_data.empty or len(price_data) < 60:
                logging.warning(f"Not enough data for {ticker}, skipping.")
                continue
            
            indicator_calc = IndicatorCalculator(price_data)
            data_with_ind = indicator_calc.calculate_all(strategy_config)
            
            optimizer = Optimizer(data_with_ind, strategy_config)
            results = optimizer.run_optimization()
            if not results:
                logging.warning(f"Optimization yielded no results for {ticker}, skipping.")
                continue

            best_result = max(results, key=lambda x: x.get('final_value', -np.inf))
            metrics = PerformanceAnalyzer.calculate_all_metrics(best_result)
            all_individual_results.append({'ticker': ticker, 'best_result': best_result, 'metrics': metrics, 'equity_curve': best_result['equity_curve']})
            report_gen.generate_html_report(ticker, results, best_result, metrics, benchmark_data, strategy_config)

        # --- 포트폴리오 종합 분석 ---
        if all_individual_results:
            all_returns = pd.concat([res['equity_curve'].pct_change() for res in all_individual_results], axis=1)
            portfolio_daily_returns = all_returns.mean(axis=1).fillna(0)
            portfolio_equity_curve = (1 + portfolio_daily_returns).cumprod() * 1e8
            
            all_trades = [trade for res in all_individual_results for trade in res['best_result']['trades']]
            portfolio_metrics = PerformanceAnalyzer.calculate_all_metrics({'trades': all_trades}, equity_curve=portfolio_equity_curve)
            benchmark_metrics = PerformanceAnalyzer.calculate_all_metrics({'trades': []}, equity_curve=benchmark_data['Close'])
            
            bench_equity = benchmark_data['Close'] / benchmark_data['Close'].iloc[0] * portfolio_equity_curve.iloc[0]
            portfolio_annual = portfolio_equity_curve.resample('YE').last().pct_change().dropna() * 100
            benchmark_annual = bench_equity.resample('YE').last().pct_change().dropna() * 100
            annual_df = pd.DataFrame({'Portfolio': portfolio_annual, 'Benchmark': benchmark_annual})
            if not annual_df.empty:
                annual_df.index = annual_df.index.year
                annual_df['초과 성과 (Portfolio - KOSPI)'] = annual_df['Portfolio'] - annual_df['Benchmark']

            report_gen.generate_portfolio_summary_report(portfolio_metrics, portfolio_equity_curve, all_individual_results, benchmark_data, annual_df)
            report_gen.print_terminal_summary(portfolio_metrics)
            ai_comment = report_gen.generate_ai_commentary(portfolio_metrics, benchmark_metrics, annual_df, all_individual_results)
            print(ai_comment)
            history_manager.update_history(strategy_file_path, tickers, portfolio_metrics)
        else:
            logging.warning("No successful backtests were run. Skipping portfolio analysis.")

    except Exception as e:
        logging.error(f"Fatal error in main execution: {e}", exc_info=True)